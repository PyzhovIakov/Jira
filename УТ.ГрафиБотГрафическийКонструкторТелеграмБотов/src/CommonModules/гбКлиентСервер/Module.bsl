
#Область ПрограммныйИнтерфейс

// Разбирает строку URI на составные части и возвращает в виде структуры.
// На основе RFC 3986.
//
// Параметры:
//  СтрокаURI - Строка - ссылка на ресурс в формате:
//                       <схема>://<логин>:<пароль>@<хост>:<порт>/<путь>?<параметры>#<якорь>.
//
// Возвращаемое значение:
//  Структура - составные части URI согласно формату:
//   * Схема         - Строка - схема из URI.
//   * Логин         - Строка - логин из URI.
//   * Пароль        - Строка - пароль из URI.
//   * ИмяСервера    - Строка - часть <хост>:<порт> из URI.
//   * Хост          - Строка - хост из URI.
//   * Порт          - Строка - порт из URI.
//   * ПутьНаСервере - Строка - часть <путь>?<параметры>#<якорь> из URI.
//
Функция СтруктураURI(Знач СтрокаURI) Экспорт
	
	СтрокаURI = СокрЛП(СтрокаURI);
	
	// схема
	Схема = "";
	Позиция = СтрНайти(СтрокаURI, "://");
	Если Позиция > 0 Тогда
		Схема = НРег(Лев(СтрокаURI, Позиция - 1));
		СтрокаURI = Сред(СтрокаURI, Позиция + 3);
	КонецЕсли;
	
	// Строка соединения и путь на сервере.
	СтрокаСоединения = СтрокаURI;
	ПутьНаСервере = "";
	Позиция = СтрНайти(СтрокаСоединения, "/");
	Если Позиция > 0 Тогда
		ПутьНаСервере = Сред(СтрокаСоединения, Позиция + 1);
		СтрокаСоединения = Лев(СтрокаСоединения, Позиция - 1);
	КонецЕсли;
	
	// Информация пользователя и имя сервера.
	СтрокаАвторизации = "";
	ИмяСервера = СтрокаСоединения;
	Позиция = СтрНайти(СтрокаСоединения, "@");
	Если Позиция > 0 Тогда
		СтрокаАвторизации = Лев(СтрокаСоединения, Позиция - 1);
		ИмяСервера = Сред(СтрокаСоединения, Позиция + 1);
	КонецЕсли;
	
	// логин и пароль
	Логин = СтрокаАвторизации;
	Пароль = "";
	Позиция = СтрНайти(СтрокаАвторизации, ":");
	Если Позиция > 0 Тогда
		Логин = Лев(СтрокаАвторизации, Позиция - 1);
		Пароль = Сред(СтрокаАвторизации, Позиция + 1);
	КонецЕсли;
	
	// хост и порт
	Хост = ИмяСервера;
	Порт = "";
	Позиция = СтрНайти(ИмяСервера, ":");
	Если Позиция > 0 Тогда
		Хост = Лев(ИмяСервера, Позиция - 1);
		Порт = Сред(ИмяСервера, Позиция + 1);
		Если Не ТолькоЦифрыВСтроке(Порт) Тогда
			Порт = "";
		КонецЕсли;
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("Схема", Схема);
	Результат.Вставить("Логин", Логин);
	Результат.Вставить("Пароль", Пароль);
	Результат.Вставить("ИмяСервера", ИмяСервера);
	Результат.Вставить("Хост", Хост);
	Результат.Вставить("Порт", ?(ПустаяСтрока(Порт), Неопределено, Число(Порт)));
	Результат.Вставить("ПутьНаСервере", ПутьНаСервере);
	
	Возврат Результат;
	
КонецФункции

// Проверяет, содержит ли строка только цифры.
//
// Параметры:
//  Значение         - Строка - проверяемая строка.
//
// Возвращаемое значение:
//   Булево - Истина - строка содержит только цифры, Ложь - строка содержит иные символы.
//
// Пример:
//  Результат = ТолькоЦифрыВСтроке("0123"); // Истина
//  Результат = ТолькоЦифрыВСтроке("0123abc"); // Ложь
//
Функция ТолькоЦифрыВСтроке(Знач Значение) Экспорт
	
	Если ТипЗнч(Значение) <> Тип("Строка") Тогда
		Возврат Ложь;
	ИначеЕсли СтрДлина(Значение) = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// Если содержит только цифры, то в результате замен должна быть получена пустая строка.
	// Проверять при помощи ПустаяСтрока нельзя, так как в исходной строке могут быть пробельные символы.
	Возврат СтрДлина(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить(
		СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( СтрЗаменить( 
			Значение, "0", ""), "1", ""), "2", ""), "3", ""), "4", ""), "5", ""), "6", ""), "7", ""), "8", ""), "9", "")) = 0;
	
КонецФункции

// Проверяет, является ли строка уникальным идентификатором.
// В качестве уникального идентификатора предполагается строка вида
// "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX", где X = [0..9,a..f].
//
// Параметры:
//  Значение - Строка - проверяемая строка.
//
// Возвращаемое значение:
//  Булево - Истина, если переданная строка является уникальным идентификатором.
//
Функция ЭтоУникальныйИдентификатор(Знач Значение) Экспорт
	
	Шаблон = "XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX";
	
	Если СтрДлина(Шаблон) <> СтрДлина(Значение) Тогда
		Возврат Ложь;
	КонецЕсли;
	Для Позиция = 1 По СтрДлина(Значение) Цикл
		Если КодСимвола(Шаблон, Позиция) = 88 // X
			И ((КодСимвола(Значение, Позиция) < 48 Или КодСимвола(Значение, Позиция) > 57) // 0..9
			И (КодСимвола(Значение, Позиция) < 97 Или КодСимвола(Значение, Позиция) > 102) // a..f
			И (КодСимвола(Значение, Позиция) < 65 Или КодСимвола(Значение, Позиция) > 70)) // A..F
			Или КодСимвола(Шаблон, Позиция) = 45 И КодСимвола(Значение, Позиция) <> 45 Тогда // -
				Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;

КонецФункции

// Преобразует исходную строку в дату.
//
// Параметры:
//  Значение - Строка - Строка, которую необходимо привести к дате.
//                      Формат даты должен быть в виде "ДД.ММ.ГГГГ" или "ДД/ММ/ГГ",
//                      Например, "23.02.1980" или "23/02/80".
// 
// Возвращаемое значение:
//  Дата - полученная дата.
//
Функция СтрокаВДату(Знач Значение) Экспорт
	
	Значение = СокрЛП(СтрЗаменить(Значение, ".", " "));
	Значение = СокрЛП(СтрЗаменить(Значение, "/", " "));
	Значение = СокрЛП(СтрЗаменить(Значение, "-", " "));
	
	Данные = СтрРазделить(Значение, " ");
	Если Данные.Количество() < 2 тогда
		Возврат Неопределено;
	ИначеЕсли Данные.Количество() = 2 тогда
		Данные.Добавить(Формат(Год(ТекущаяДата()), "ЧГ="));
	КонецЕсли;
	Данные[2] = СтрЗаменить(НРег(Данные[2]), "г", "");
	
	Если Данные.Количество() < 3 
		или не ТолькоЦифрыВСтроке(Данные[0]) или Число(Данные[0]) = 0
		или не ТолькоЦифрыВСтроке(Данные[2]) 
		или не (СтрДлина(Данные[2]) = 2 или СтрДлина(Данные[2]) = 4) 
		тогда
		Возврат Неопределено;
	КонецЕсли;

	Если ТолькоЦифрыВСтроке(Данные[1]) тогда
		Месяц = Число(Данные[1]);
	Иначе
		Месяцы = СтрРазделить("хххх,янв,фев,мар,апр,май,июн,июл,авг,сен,окт,ноя,дек", ",");
		Месяц = Месяцы.Найти(НРег(лев(Данные[1], 3)));
	КонецЕсли;
	Если не ЗначениеЗаполнено(Месяц) или Месяц > 12 тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Если СтрДлина(Данные[2]) = 4 тогда
		Год = Число(Данные[2]);
	Иначе
		Год = Число(?(Число(Данные[2]) > 39, "19", "20") + Данные[2]);
	КонецЕсли;
	
	Дата = Дата(Год, Месяц, 1);
	
	День = Число(Данные[0]);
	Если День = 0 тогда // и День > День(КонецМесяца(Дата))
		Возврат Неопределено;
	КонецЕсли;
	Дата = Дата + (День - 1)*24*60*60;
	
	Возврат Дата;
	
КонецФункции 

// Преобразует исходную строку во время.
//
// Параметры:
//  Значение - Строка - Строка, которую необходимо привести к дате.
// 
// Возвращаемое значение:
//  Дата - полученная дата.
//
Функция СтрокаВоВремя(Знач Значение) Экспорт
	
	Значение = СокрЛП(СтрЗаменить(Значение, ".", " "));
	Значение = СокрЛП(СтрЗаменить(Значение, ":", " "));
	Значение = СокрЛП(СтрЗаменить(Значение, ";", " "));
	Значение = СокрЛП(СтрЗаменить(Значение, "/", " "));
	Значение = СокрЛП(СтрЗаменить(Значение, "-", " "));
	
	Данные = СтрРазделить(Значение, " ");
	Если Данные.Количество() < 2 
		или не ТолькоЦифрыВСтроке(Данные[0]) 
		или не ТолькоЦифрыВСтроке(Данные[1]) тогда
		Возврат Неопределено;
	КонецЕсли;
	Дата = '00010101' + 60*60*Данные[0] + 60*Данные[1];
	
	Возврат Дата;
	
КонецФункции 


// Вычисляет дату границы периода
//
// Параметры:
//  пВидГраницы	 - Строка	 - "Начало" или "Конец"
//  пВидПериода	 - Строка	 - "День", "Неделя", ...
//  Дата		 - Дата	 - дата в периоде
// 
// Возвращаемое значение:
//  Дата - граница периода
//
Функция ГраницаПериода(пВидГраницы, пВидПериода, Дата) Экспорт
	
	Возврат Вычислить(пВидГраницы + пВидПериода + "(Дата)");
	
КонецФункции

// Возвращает начало полугодия
//
// Параметры:
//  Дата - Дата	 - выбранная дата
// 
// Возвращаемое значение:
//  Дата - дата начала полугодия
//
Функция НачалоПолугодия(Дата) Экспорт
	Результат = НачалоКвартала(Дата);
	Если Месяц(Результат) = 4 или Месяц(Результат) = 10 тогда
		Результат = НачалоКвартала(Результат - 1);
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Возвращает конец полугодия
//
// Параметры:
//  Дата - Дата	 - выбранная дата
// 
// Возвращаемое значение:
//  Дата - дата конец полугодия
//
Функция КонецПолугодия(Дата) Экспорт
	Результат = КонецКвартала(Дата);
	Если Месяц(Результат) = 3 или Месяц(Результат) = 9 тогда
		Результат = КонецКвартала(Результат + 1);
	КонецЕсли;
	Возврат Результат;
КонецФункции

// Проверяет, содержит ли строка только символы латинского алфавита.
//
// Параметры:
//  СтрокаПроверки - Строка - проверяемая строка.
//  ДопустимыеСимволы - Строка - дополнительные разрешенные символы, кроме латиницы.
//
// Возвращаемое значение:
//  Булево - Истина, если строка содержит только латинские (или допустимые) символы;
//         - Ложь, если строка содержит иные символы.
//
Функция ТолькоЛатиницаВСтроке(Знач СтрокаПроверки, ДопустимыеСимволы = "") Экспорт
	
	Если ТипЗнч(СтрокаПроверки) <> Тип("Строка") Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаПроверки) Тогда
		Возврат Истина;
	КонецЕсли;
	
	КодыДопустимыхСимволов = Новый Массив;
	
	Для Индекс = 1 По СтрДлина(ДопустимыеСимволы) Цикл
		КодыДопустимыхСимволов.Добавить(КодСимвола(Сред(ДопустимыеСимволы, Индекс, 1)));
	КонецЦикла;
	
	Для Индекс = 1 По СтрДлина(СтрокаПроверки) Цикл
		КодСимвола = КодСимвола(Сред(СтрокаПроверки, Индекс, 1));
		Если ((КодСимвола < 65) Или (КодСимвола > 90 И КодСимвола < 97) Или (КодСимвола > 122))
			И (КодыДопустимыхСимволов.Найти(КодСимвола) = Неопределено)  Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
	
КонецФункции

// Создает массив и помещает в него переданное значение.
//
// Параметры:
//  Значение - Произвольный - любое значение.
//
// Возвращаемое значение:
//  Массив - массив из одного элемента.
//
Функция ЗначениеВМассиве(Значение) Экспорт
	
	Массив = Новый Массив;
	Массив.Добавить(Значение);
	
	Возврат Массив;
	
КонецФункции

// Формирует и выводит сообщение, которое может быть связано с элементом 
// управления формы.
//
// Параметры:
//  ТекстСообщенияПользователю - Строка - текст сообщения.
//  КлючДанных                 - ЛюбаяСсылка - объект или ключ записи информационной базы, к которому это сообщение относится.
//  Поле                       - Строка - наименование реквизита формы.
//  ПутьКДанным                - Строка - путь к данным (путь к реквизиту формы).
//  Отказ                      - Булево - выходной параметр, всегда устанавливается в значение Истина.
//
// Пример:
//
//  1. Для вывода сообщения у поля управляемой формы, связанного с реквизитом объекта:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ПолеВРеквизитеФормыОбъект",
//   "Объект");
//
//  Альтернативный вариант использования в форме объекта:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "Объект.ПолеВРеквизитеФормыОбъект");
//
//  2. Для вывода сообщения рядом с полем управляемой формы, связанным с реквизитом формы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ,
//   "ИмяРеквизитаФормы");
//
//  3. Для вывода сообщения связанного с объектом информационной базы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), ОбъектИнформационнойБазы, "Ответственный",,Отказ);
//
//  4. Для вывода сообщения по ссылке на объект информационной базы:
//  ОбщегоНазначенияКлиентСервер.СообщитьПользователю(
//   НСтр("ru = 'Сообщение об ошибке.'"), Ссылка, , , Отказ);
//
//  Случаи некорректного использования:
//   1. Передача одновременно параметров КлючДанных и ПутьКДанным.
//   2. Передача в параметре КлючДанных значения типа отличного от допустимых.
//   3. Установка ссылки без установки поля (и/или пути к данным).
//
Процедура СообщитьПользователю(
		Знач ТекстСообщенияПользователю,
		Знач КлючДанных = Неопределено,
		Знач Поле = "",
		Знач ПутьКДанным = "",
		Отказ = Ложь) Экспорт
	
	Сообщение = Новый СообщениеПользователю;
	Сообщение.Текст = ТекстСообщенияПользователю;
	Сообщение.Поле = Поле;
	
	ЭтоОбъект = Ложь;
	
#Если НЕ ТонкийКлиент И НЕ ВебКлиент Тогда
	Если КлючДанных <> Неопределено
	   И XMLТипЗнч(КлючДанных) <> Неопределено Тогда
		ТипЗначенияСтрокой = XMLТипЗнч(КлючДанных).ИмяТипа;
		ЭтоОбъект = СтрНайти(ТипЗначенияСтрокой, "Object.") > 0;
	КонецЕсли;
#КонецЕсли
	
	Если ЭтоОбъект Тогда
		Сообщение.УстановитьДанные(КлючДанных);
	Иначе
		Сообщение.КлючДанных = КлючДанных;
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПутьКДанным) Тогда
		Сообщение.ПутьКДанным = ПутьКДанным;
	КонецЕсли;
		
	Сообщение.Сообщить();
	
	Отказ = Истина;
	
КонецПроцедуры

// Извлекает подстроки в квадратных скобках из строки с учетом кавычек
//
// Параметры:
//  Строка	 - Строка	 - Исходная строка
// 
// Возвращаемое значение:
//  Массив - Найденные подстроки
//
Функция ПолучитьШаблоныПодстановкиИзСтроки(Строка) Экспорт
	
	Результат = Новый Массив;
	Позиция = СтрНайти(Строка, "[");
	Пока Позиция цикл
		Позиция1 = СтрНайти(Строка, "]", , Позиция);
		Подстрока = Сред(Строка, Позиция + 1, Позиция1 - Позиция - 1);
		Пока Позиция1 
			и ((СтрЧислоВхождений(Подстрока, """") % 2)
				или (СтрЧислоВхождений(Подстрока, "[") <> СтрЧислоВхождений(Подстрока, "]"))) цикл
 			Позиция1 = СтрНайти(Строка, "]", , Позиция1 + 1);
			Подстрока = Сред(Строка, Позиция + 1, Позиция1 - Позиция - 1);
		КонецЦикла;
		Если Позиция1 тогда
			Результат.Добавить(Сред(Строка, Позиция + 1, Позиция1 - Позиция - 1));
		КонецЕсли;
		
		Позиция = СтрНайти(Строка, "[", , мин(макс(Позиция, Позиция1) + 1, СтрДлина(Строка)));
	КонецЦикла;

	Возврат Результат;
КонецФункции

#КонецОбласти

