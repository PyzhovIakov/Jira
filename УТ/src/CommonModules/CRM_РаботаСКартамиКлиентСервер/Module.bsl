
#Область СлужебныеПроцедурыИФункции

#Область ФункцииКонвертирования

// Возвращает строку-представление координат в читабельном для пользователя виде.
// Координаты передаются в формате NMEA.
//
Функция NMEAвСтроку(Коор) Экспорт
	Ч = Цел(Коор / 100);
	М = Цел(Коор - 100 * Ч);
	С = Окр((Коор - Цел(Коор)) * 60, 2);
	ЧСтр = Строка(Ч);
	МСтр = Формат(М, "ЧЦ=2;ЧВН=;ЧН=");
	ССтр = Формат(С, "ЧЦ=4;ЧДЦ=2;ЧРД=.;ЧВН=;ЧН=");
	Возврат ЧСтр + "°" + МСтр + "'" + ССтр + """";
КонецФункции

// Возвращает строку-представление координат в читабельном для пользователя виде.
// Координаты передаются в формате NMEA.
//
Функция ПредставениеКоординат(Широта, Долгота) Экспорт
	Если Широта = 0 И Долгота = 0 Тогда
		Возврат НСтр("ru='Координаты не указаны.';uk='Координати не вказані.'");	
	Иначе
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Широта: %1;
			| Долгота: %2';uk='Широта: %1; Довгота: %2'"),
																				NMEAвСтроку(Широта), NMEAвСтроку(Долгота));	
	КонецЕсли;
КонецФункции

Функция КонвертироватьNMEAWGS84(Значение) Экспорт
	Пром =  Значение / 100.0;  
	Часы = Пром - (Пром % 1); 
	Минуты = Значение - 100.0 * Часы;
	Результат = Часы + Минуты / 60.0;
	Возврат Окр(Результат, 6);
КонецФункции

Функция КоординатаИзWGS84вNMEA(Координата) Экспорт
	
	Возврат Цел(Координата) * 100 + (Координата - Цел(Координата)) * 60;
	
КонецФункции
// Конвертирует переданные координаты из формата WGS84 в формат NMEA. 
//
//  Параметры:
//   Координаты - Массив - массив координат
//
//  Возвращаемое значение:
//   КоординатыNMEA - Строка - строка из координат, разделенных пробелом
//
Функция КонвертироватьWGS84NMEA(стрКоординаты) Экспорт
	
	Результат = "";
	
	Индекс = СтрНайти(стрКоординаты, " ");
	Если Индекс <> 0 Тогда
		ДолготаWGS84 = Число(Лев(стрКоординаты, Индекс - 1));
		ШиротаWGS84  = Число(Сред(стрКоординаты, Индекс + 1));
		Долгота = CRM_РаботаСКартамиКлиентСервер.КоординатаИзWGS84вNMEA(ДолготаWGS84);
		Широта 	= CRM_РаботаСКартамиКлиентСервер.КоординатаИзWGS84вNMEA(ШиротаWGS84);
		Результат = СтрЗаменить(Строка(Широта), " ", "") + " " + СтрЗаменить(Строка(Долгота), " ", "");
	КонецЕсли; 
	
	Возврат Результат;

	//МассивКоординат = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Координаты, " ");
	//
	// Если МассивКоординат.Количество() < 2 Тогда
	//	Возврат "";
	//КонецЕсли;	
	//
	//НайденныеКоординатыX = МассивКоординат[0]; 
	//НайденныеКоординатыY = МассивКоординат[1];
	//
	//НайденныеКоординатыX = Цел(НайденныеКоординатыX)*100 + (НайденныеКоординатыX-Цел(НайденныеКоординатыX))*60;
	//НайденныеКоординатыY = Цел(НайденныеКоординатыY)*100 + (НайденныеКоординатыY-Цел(НайденныеКоординатыY))*60;
	//
	//КоординатыNMEA = Строка(НайденныеКоординатыX) + " " + Строка(НайденныеКоординатыY);
	//
	// Возврат КоординатыNMEA;
	
КонецФункции

Функция ПереводЧислаВСистемуСчисления(
		Знач Значение = 0, 
		Нотация = 64, 
		СтрокаСистемы = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz+/")
		
	Если Нотация <= 0 Тогда 
		Возврат ""; 
	КонецЕсли;
	Если Значение <= 0 Тогда 
		Возврат "0"; 
	КонецЕсли;
	Значение = Цел(Значение);
	Результат = "";
	Пока Значение > 0 Цикл
		Результат = Сред(СтрокаСистемы, Значение % Нотация + 1, 1) + Результат;
		Значение = Цел (Значение / Нотация);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

Функция СимволВ16(Символ)
	
	Возврат "%" + ПереводЧислаВСистемуСчисления(КодСимвола(Символ), 16);
	
КонецФункции

Функция ПреобразоватьСтрокуВУТФ8(Стр) Экспорт
	
	// Multilanguage - начало
	Длина = СтрДлина(Стр);
	Итог = "";
	Для Н = 1 По Длина Цикл
		Знак = Сред(Стр, Н, 1);
		Код = КодСимвола(Знак);
		Если Код = 32 Тогда
			Итог = Итог + СимволВ16(Знак);
		ИначеЕсли Код < 128 Тогда
			Итог = Итог + Знак;
		Иначе
			Если (Код >= КодСимвола("А")) И (Код <= КодСимвола("п")) Тогда
				Итог = Итог + СимволВ16(Символ(208)) + СимволВ16(Символ(144 + Код - КодСимвола("А")));
			ИначеЕсли (Код >= КодСимвола("р")) И (Код <= КодСимвола("я")) Тогда
				Итог = Итог + СимволВ16(Символ(209)) + СимволВ16(Символ(128 + Код - КодСимвола("р")));
			ИначеЕсли (Знак = "ё") Тогда
				Итог = Итог + СимволВ16(Символ(209)) + СимволВ16(Символ(145));
			ИначеЕсли (Знак = "Ё") Тогда
				Итог = Итог + СимволВ16(Символ(208)) + СимволВ16(Символ(129));
			КонецЕсли;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Итог;
	// Multilanguage - конец
	
КонецФункции

#КонецОбласти // ФункцииКонвертирования

#Область ПоискКратчайшегоПути

Процедура ДобавитьТочкуВМассив(МассивТочек, СтррТочка, ВНачало = Ложь) Экспорт
	
	Если ВНачало Тогда
		МассивТочек.Вставить(0,
			 КонвертироватьNMEAWGS84(СтррТочка.Долгота)); // вставка в обратном порядке - сначала долгота, потом широта
		МассивТочек.Вставить(0, КонвертироватьNMEAWGS84(СтррТочка.Широта));
	Иначе
		МассивТочек.Добавить(КонвертироватьNMEAWGS84(СтррТочка.Широта)); // добавление в конец массива - сначала широта, потом долгота
		МассивТочек.Добавить(КонвертироватьNMEAWGS84(СтррТочка.Долгота));
	КонецЕсли;
	
КонецПроцедуры

Функция РасстояниеМеждуТочками(StartLat, StartLong, EndLat, EndLong) Экспорт 

	// Pi = 3.1415926535897932;

	// Передаваемые широта/долгота в градусах и сотых долях
	// StartLat: double; // Начальная широта
	// StartLong: double; // Начальная долгота
	// EndLat: double; // Конечная широта
	// EndLong: double; // Конечная долгота
	
	// // Переменные, используемые для вычисления смещения и расстояния
	// fPhimean: Double; // Средняя широта
	// fdLambda: Double; // Разница между двумя значениями долготы
	// fdPhi: Double; // Разница между двумя значениями широты
	// fAlpha: Double; // Смещение
	// fRho: Double; // Меридианский радиус кривизны
	// fNu: Double; // Поперечный радиус кривизны
	// fR: Double; // Радиус сферы Земли
	// fz: Double; // Угловое расстояние от центра сфероида
	// fTemp: Double; // Временная переменная, использующаяся в вычислениях
	// Distance: Double; // Вычисленное расстояния в метрах
	// Bearing: Double; // Вычисленное от и до смещение

	Если StartLat = EndLat И StartLong = EndLong Тогда
		Возврат 0;
	КонецЕсли;
	
	// Константы, используемые для вычисления смещения и расстояния
	D2R = 0.017453; // Константа для преобразования градусов в радианы
	a = 6378137.0; // Основные полуоси
	e2 = 0.006739496742337; // Квадрат эксцентричности эллипсоида

	fdLambda = (StartLong - EndLong) * D2R;
	fdPhi = (StartLat - EndLat) * D2R;
	fPhimean = ((StartLat + EndLat) / 2.0) * D2R;
	
	// Вычисляем меридианные и поперечные радиусы кривизны средней широты
	fTemp = 1 - e2 * (Pow(Sin(fPhimean), 2));
	fRho = (a * (1 - e2)) / Pow(fTemp, 1.5);
	fNu = a / (Sqrt(1 - e2 * (Sin(fPhimean) * Sin(fPhimean))));
	
	// Вычисляем угловое расстояние
	fz = Sqrt(Pow(Sin(fdPhi / 2.0), 2) + Cos(EndLat * D2R) * Cos(StartLat * D2R) * Pow(Sin(fdLambda / 2.0), 2));
	
	fz = 2 * ASin(fz);
	
	// Вычисляем смещение
	fAlpha = Cos(EndLat * D2R) * Sin(fdLambda) * 1 / Sin(fz);
	
	Если fAlpha > 1 Тогда
		fAlpha = 1;
	ИначеЕсли fAlpha < -1 Тогда
		fAlpha = -1;
	КонецЕсли;
	
	fAlpha = ASin(fAlpha);
	
	// Вычисляем радиус Земли
	fR = (fRho * fNu) / ((fRho * Pow(Sin(fAlpha), 2)) + (fNu * Pow(Cos(fAlpha), 2)));
	
	// Получаем смещение и расстояние
	Distance = (fz * fR);
	
	Возврат Distance;
	
КонецФункции

// Для ускорения вычислений передается параметр количества точек меньше на 1
// ТипМаршрута:
//  0 - замкнутый маршрут
//  1 - из одной точки
//  2 - между двумя точками
//
Функция РассчитатьДлинуМаршрута(Маршрут, МРасстояния, КолТочек_1, ТипМаршрута)
	
	Если ТипМаршрута <= 0 Тогда
		Длина = МРасстояния[Маршрут[КолТочек_1]][Маршрут[0]]; // замыкаем маршрут - важно соблюдать несимметрию - отрезок до нулевой точки, а не после нулевой!
	ИначеЕсли ТипМаршрута = 1 Тогда
		Длина = 0;
	ИначеЕсли ТипМаршрута = 2 Тогда
		Длина = 0;
	Иначе
		Возврат СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Неизвестный тип маршрута: %1';
			| uk='Невідомий тип маршруту: %1'"),
																				Строка(ТипМаршрута));	
	КонецЕсли;
		
	Для Поз = 1 По КолТочек_1 Цикл  // Gri++ по замерам производительности - 
									// лучше тут указывать выражение, чем результат из локальной временной переменной
		Длина = Длина + МРасстояния[Маршрут[Поз - 1]][Маршрут[Поз]];  
	КонецЦикла;
	Маршрут[КолТочек_1 + 1] = Длина;
	
	Возврат Длина;
	
КонецФункции

// Расчет длины маршрута с предварительной оптимизацией маршрута.
// 
// ТипМаршрута:
//  0 - замкнутый маршрут
//  1 - из одной точки
//  2 - между двумя точками
//
Функция РассчитатьДлинуМаршрутаИОптимизировать(Маршрут, МРасстояния, КолТочек)
	
	КолТочек_1 = КолТочек - 1;
	
	Длина = МРасстояния[Маршрут[КолТочек_1]][Маршрут[0]]; // замыкаем маршрут - важно соблюдать несимметрию - отрезок до нулевой точки, а не после нулевой!
	
	Для Поз = 1 По КолТочек_1 Цикл  // Gri++ по замерам производительности -
									// лучше тут указывать выражение, чем результат из локальной временной переменной
		Длина = Длина + МРасстояния[Маршрут[Поз - 1]][Маршрут[Поз]];  
	КонецЦикла;
	
	мБуфер = Новый Массив(КолТочек);
	ТекДлина = Неопределено;
	
	Пока ТекДлина <> Длина Цикл // Цикл оптимизации - если длина маршрута сократилась, запускаем повторно
		
		ТекДлина = Длина;

		Для n = 0 По КолТочек_1 - 2 Цикл // было КолТочек_1 - 3, но при этом условии на тестах цепочка не сокращалась
			
			Для i = 0 По КолТочек_1 Цикл
				
				ip1 = ?(i = КолТочек_1, 0, i + 1);
				k = i + 2;
				Если k > КолТочек_1 Тогда
					k = k - КолТочек;
				КонецЕсли;
				
				kn = k + n;
				Если kn > КолТочек_1 Тогда
					kn = kn - КолТочек;
				КонецЕсли;
				
				km1 = ip1; // эквивалент k-1
				knp1 = ?(kn = КолТочек_1, 0, kn + 1);
				
				Pti = Маршрут[i]; // для ускорения
				
				Пока knp1 <> i Цикл 
					
					Изменение = МРасстояния[Pti][Маршрут[k]] + МРасстояния[Маршрут[kn]][Маршрут[ip1]] 
						+ МРасстояния[Маршрут[km1]][Маршрут[knp1]]
							  - МРасстояния[Pti][Маршрут[ip1]] - МРасстояния[Маршрут[km1]][Маршрут[k]] - МРасстояния[Маршрут[kn]][Маршрут[knp1]];
							  
					Если Окр(Изменение, 3) < 0 Тогда // перестановка двух участков маршрута местами
						
						d = k;
						Для s = 0 По n Цикл // копируем правый участок маршрута в буфер
							мБуфер[s] = Маршрут[d];
							d = ?(d = КолТочек_1, 0, d + 1);
						КонецЦикла;
						s = km1;
						d = kn;
						Пока s <> i Цикл   // двигаемся справа налево - левый участок переносим на место хвоста правого участка
							Маршрут[d] = Маршрут[s];     
							s = ?(s = 0, КолТочек_1, s - 1);
							d = ?(d = 0, КолТочек_1, d - 1);
						КонецЦикла;
						d = ip1;
						Для s = 0 По n Цикл // правый участок из буфера переносим на место левого участка
							Маршрут[d] = мБуфер[s];
							d = ?(d = КолТочек_1, 0, d +  1);
						КонецЦикла;
						
						Длина = Длина + Изменение;
						Если Длина < 0 Тогда
							ТекстСообщения =
								СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Отладка. Длина меньше нуля! %1. Изменение: %2';
								|uk='Налагодження. Довжина менше нуля! %1. Зміна: %2'"),
																									Строка(Окр(Длина, 3)), Строка(Окр(Изменение, 3)));
							ВызватьИсключение(ТекстСообщения);
						КонецЕсли;
						//Пром = РассчитатьДлинуМаршрута(Маршрут, МРасстояния, КолТочек_1, 0);
						// Если Окр(Длина,3) <> Окр(Пром,3) Тогда
						//	ВызватьИсключение("Длина отличается от расчетной! " + Строка(Окр(Длина,3))
						//	+ " . Расчетная: " + Строка(Окр(Пром,
						//	3)));
						//КонецЕсли;
					Иначе
						
						km1 = k;
						k = ?(k = КолТочек_1, 0, k + 1);
						kn = knp1;
						knp1 = ?(knp1 = КолТочек_1, 0, knp1 + 1);
						
					КонецЕсли;
					
				КонецЦикла; // Пока knp1 <> i Цикл 

			КонецЦикла;
			
		КонецЦикла;
			
	КонецЦикла;  // Цикл оптимизации
	
	Маршрут[КолТочек] = Длина;
	
	Возврат Длина;
	
КонецФункции

// Встряхивание оптимизированного маршрута - увеличивает вероятность быстрого нахождения кратчайшего пути.
//
Процедура ВстряхнутьМаршрут(Маршрут, МРасстояния, КолТочек, ТипМаршрута)
	
	ЛучшийМаршрут = Новый Массив(КолТочек + 1);
	
	Для Поз = 0 По КолТочек Цикл // Копируем маршрут
		ЛучшийМаршрут[Поз] = Маршрут[Поз];
	КонецЦикла;
	
	Если ТипМаршрута <= 0 Тогда
		КолПопыток = КолТочек / 10;
	ИначеЕсли ТипМаршрута = 1 Тогда
		КолПопыток = КолТочек / 10 + 2; 
	Иначе // между двумя точками
		КолПопыток = КолТочек / 10;
	КонецЕсли;
	
	КолПерестановок = КолТочек / 5;
	Случ = Новый ГенераторСлучайныхЧисел();
	КолТочек05 = Цел(КолТочек / 2);
	
	Для Поз = 1 По КолПопыток Цикл // количество попыток "встряхивания" маршрута
		// BSLLS:UnusedLocalVariable-off
		Для Перестановка = 1 По КолПерестановок Цикл
		// BSLLS:UnusedLocalVariable-on
			Поз1 = Случ.СлучайноеЧисло(0, КолТочек - 1); // случайный индекс точки в маршруте
			Поз2 = (Поз1 + КолТочек05 + Случ.СлучайноеЧисло(1,
				 КолТочек05) - 1) % КолТочек; // случайный индекс второй точки в маршруте (не должен быть рядом с первым)
			Пром = Маршрут[Поз1];
			Маршрут[Поз1] = Маршрут[Поз2];
			Маршрут[Поз2] = Пром;
		КонецЦикла;
		
		СтараяДлина = Маршрут[КолТочек];
		РассчитатьДлинуМаршрутаИОптимизировать(Маршрут, МРасстояния, КолТочек);
		
		Если СтараяДлина > Маршрут[КолТочек] Тогда // маршрут улучшился
			Для Поз0 = 0 По КолТочек Цикл // Копируем маршрут
				ЛучшийМаршрут[Поз0] = Маршрут[Поз0];
			КонецЦикла;
		КонецЕсли;
		
	КонецЦикла;
	
	Если ЛучшийМаршрут[КолТочек] < Маршрут[КолТочек] Тогда
		Для Поз = 0 По КолТочек Цикл // Копируем маршрут
			Маршрут[Поз] = ЛучшийМаршрут[Поз];
		КонецЦикла;
	КонецЕсли;

КонецПроцедуры

Функция Факториал(N)
	Если N < 2 Тогда
		Возврат 1;
	КонецЕсли;
	Результат = 2;
	Для Множитель = 3 По N Цикл
		Результат = Результат * Множитель;
	КонецЦикла;
	Возврат Результат;
КонецФункции

// Вспомогательная функция для функции permutation_by_num
//
Function notUsed(M_used, i_blockNum, Size_1)
	pos = 0;
	For j = 1 To Size_1 Do
		If Not M_used[j] Then
			pos = pos + 1;
		EndIf;
		If i_blockNum = pos Then
			Break;
		EndIf;
	EndDo;
	Return j;
EndFunction

// Функция генерирует уникальную перестановку номеров точек в массиве M_res[] в зависимости 
// от порядкового номера перестановки num.
// Пример взят тут: http://www.everfall.com/paste/id.php?9852brl4gu72
// Параметры: 
// 
Procedure permutation_by_num(Size, Val num, M_res, M_used, M_fact)
	Size_1 = Size - 1;
	For i = 0 To Size_1 Do
		M_used[i] = False;
	EndDo;
	For i = 0 To Size_1 Do
		i_blockNum = Цел((num - 1) / M_fact[Size_1 - i]) + 1;
		j = notUsed(M_used, i_blockNum, Size_1);
		M_res[i] = j;
		M_used[j] = True;
		num = (num - 1) % M_fact[Size_1 - i] + 1;
	EndDo;
EndProcedure

// Функция ищет кратчайший маршрут перебором всех вариантов. Функция вызывается, если точек на маршруте не больше 7.
// Возвращает массив из номеров торговых точек, в порядке следования маршруту. 
// Номера точек начинаются с 1. Первая точка маршрута - в элементе с индексом [0].
//
// ТипМаршрута:
//  0 - замкнутый маршрут
//  1 - из одной точки
//  2 - между двумя точками
//
Функция НайтиМаршрутПереборомВсехВариантов(КолТочек, МРасстояния, ТипМаршрута)
	// делаем все возможные перестановки
	M_fact  = Новый Массив(14);
	M_fact[0] = 1;
	M_fact[1] = 1;
	M_fact[2] = 2;
	M_fact[3] = 6;
	M_fact[4] = 24;
	M_fact[5] = 120;
	M_fact[6] = 720;
	M_fact[7] = 5040;
	
	МаксКолВариантов = M_fact[КолТочек];
	// Если ТипМаршрута = 0 Тогда // для симметричных расстояний число всех вариантов для N точек равно N!/2
	//	МаксКолВариантов = МаксКолВариантов / 2;
	//КонецЕсли;
		
	M_used  = Новый Массив(КолТочек + 1); // так требуется по примеру http://www.everfall.com/paste/id.php?9852brl4gu72
	Маршрут = Новый Массив(КолТочек + 1); // в последнем параметре маршрута возвращается его длина
	permutation_by_num(КолТочек, 1, Маршрут, M_used, M_fact);
	КолТочек_1 = КолТочек - 1;	
	МинДлина = РассчитатьДлинуМаршрута(Маршрут, МРасстояния, КолТочек_1, ТипМаршрута);
	ЛучшийМаршрут = Новый Массив(КолТочек + 1);
	Для Поз = 0 По КолТочек Цикл // Копируем маршрут
		ЛучшийМаршрут[Поз] = Маршрут[Поз];
	КонецЦикла;
	Для Num = 2 По МаксКолВариантов Цикл
		permutation_by_num(КолТочек, num, Маршрут, M_used, M_fact);
		Длина = РассчитатьДлинуМаршрута(Маршрут, МРасстояния, КолТочек_1, ТипМаршрута);
		Если Длина < МинДлина Тогда
			МинДлина = Длина;
			Для Поз = 0 По КолТочек Цикл // Копируем маршрут
				ЛучшийМаршрут[Поз] = Маршрут[Поз];
			КонецЦикла;
		КонецЕсли;
	КонецЦикла;
	Возврат ЛучшийМаршрут;
КонецФункции

// Собственный алгоритм - перестановка цепочек (вариация алгоритма "выгорания"). 
// 
// ТипМаршрута:
//  0 - замкнутый маршрут
//  1 - из одной точки
//  2 - между двумя точками
//
Функция НайтиМаршрутЭвристически(КолТочек, МРасстояния, КоличествоВариантов, ТипМаршрута)
	
	МВариантыМаршрута = Новый Массив(КоличествоВариантов + 1, КолТочек 
		+ 1); // В 1С первый индекс в выражении [] имеет отношение к последнему измерению
	Случ = Новый ГенераторСлучайныхЧисел();
	МассивНомеров = Новый Массив(КолТочек + 1);
	// делаем варианты популяций
	КолТочек_1 = КолТочек - 1;
	// Переданный порядок точек из маршрута тоже рассматриваем как вариант - на случай его возможной оптимизации
	Маршрут = МВариантыМаршрута[0]; // запоминаем текущий вариант маршрута в 0-й позиции вариантов, после будем его сравнивать с финальным результатом - чтобы не случилось ухудшения маршрута
	Для Поз = 1 По КолТочек Цикл
		Маршрут[Поз - 1] = Поз;
	КонецЦикла;
	РассчитатьДлинуМаршрутаИОптимизировать(Маршрут,  МРасстояния, КолТочек);
	
	//ТекВремя = ТекущаяДата();
	
	// генерируем другие случайные варианты маршрута
	Для Поз = 1 По КоличествоВариантов Цикл
		Маршрут = МВариантыМаршрута[Поз];
		БылНомер = Поз % 2; // чтобы не обнулять постоянно массив испльзованных номеров
		Для Поз2 = 0 По КолТочек_1 Цикл
			СлучНомер = Случ.СлучайноеЧисло(1, КолТочек);
			Если МассивНомеров[СлучНомер] = БылНомер Тогда
				// ищем в массиве свободный номер влево или вправо от текущего
				Если Случ.СлучайноеЧисло(1, 2) = 1 Тогда
					Пока Истина Цикл
						СлучНомер = СлучНомер + 1;
						Если СлучНомер > КолТочек Тогда
							СлучНомер = 1;
						КонецЕсли;
						
						Если МассивНомеров[СлучНомер] <> БылНомер Тогда
							Прервать;
						КонецЕсли;
					КонецЦикла;
				Иначе
					Пока Истина Цикл
						СлучНомер = СлучНомер - 1;
							Если СлучНомер < 1 Тогда СлучНомер = КолТочек; КонецЕсли;
						
						Если МассивНомеров[СлучНомер] <> БылНомер Тогда
							Прервать;
						КонецЕсли;
					КонецЦикла;
				КонецЕсли;
			КонецЕсли;
			МассивНомеров[СлучНомер] = БылНомер;
			Маршрут[Поз2] = СлучНомер;
		КонецЦикла;
		РассчитатьДлинуМаршрутаИОптимизировать(Маршрут,  МРасстояния, КолТочек);
		ВстряхнутьМаршрут(Маршрут, МРасстояния, КолТочек, ТипМаршрута);
	КонецЦикла;
	
	Маршрут = МВариантыМаршрута[0];
	Длина = Маршрут[КолТочек];
	Для Поз = 1 По КоличествоВариантов Цикл
		ТекМаршрут = МВариантыМаршрута[Поз];
		ТекДлина   = ТекМаршрут[КолТочек];
		Если ТекДлина < Длина Тогда
			Маршрут = ТекМаршрут;
			Длина   = ТекДлина;
		КонецЕсли;
	КонецЦикла;

	Если Длина > МВариантыМаршрута[0][КолТочек] Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Лучшая длина: %1';
			|uk='Краща довжина: %1'"),
																									Строка(Длина));
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);					
	КонецЕсли;
	
	Возврат Маршрут;
КонецФункции

Функция НайтиОптимальныйМаршрут(МассивТочек, ПараметрыМаршрута) Экспорт
	
	Маршрут = НайтиОптимальныйМаршрутВстроенныйАлгоритм(МассивТочек, ПараметрыМаршрута);

	Если Маршрут = Неопределено Тогда
		Возврат Маршрут;
	КонецЕсли;
	
	Если ПараметрыМаршрута.ТипМаршрута <> "Замкнутый" Тогда
		Если ПараметрыМаршрута.Свойство("КоординатыНачальнойТочки")
			 Или ПараметрыМаршрута.Свойство("КоординатыОпорнойТочки") Тогда 
			// Начальная точка маршрута (точка под номером 1) вне списка торговых точек, 
			// например, это домашний адрес агента или офис. Точку нужно убрать из маршрута.
			Для Поз = 0 По Маршрут.Количество() - 2 Цикл
				Маршрут[Поз] = Маршрут[Поз] - 1;
			КонецЦикла;
			Маршрут.Удалить(Маршрут.Найти(0)); // убираем бывшую точку под номером 1
		КонецЕсли;
		Если ПараметрыМаршрута.Свойство("КоординатыКонечнойТочки") Тогда 
			// Конечная точка маршрута (последняя точка в массиве, последний элемент массива - длина маршрута) 
			// вне списка торговых точек, например, это домашний адрес агента или офис. Точку нужно убрать из маршрута.
			Маршрут.Удалить(Маршрут.ВГраница() - 1);
		КонецЕсли;
	Иначе 
		Если ПараметрыМаршрута.Свойство("КоординатыОпорнойТочки") Тогда 
			// Опорная точка маршрута (последняя точка в массиве, последний элемент массива - длина маршрута) 
			// вне списка торговых точек, например, это домашний адрес агента или офис. Точку нужно убрать из маршрута.
			Маршрут.Удалить(Маршрут.ВГраница() - 1);
		КонецЕсли;
	КонецЕсли;
	
	Возврат Маршрут;

КонецФункции

Функция ПолучитьКодТипаМаршрута(ТипМаршрута)
	
	Если ТипМаршрута = "Замкнутый" Тогда 
		Возврат 0;
	ИначеЕсли ТипМаршрута = "ОднаТочка" Тогда 
		Возврат 1;
	ИначеЕсли ТипМаршрута = "МеждуДвумяТочками" Тогда
		Возврат 2;
	Иначе
		Возврат -1;
	КонецЕсли;
	
КонецФункции

// Функция ищет оптимальный маршрут методом НайтиМаршрутЭвристически().
// На вход передается массив торговых точек.
// Массив одномерный, значения разбиты по парам: по четным индексам (включая 0) указана широта точки, 
// по нечетным - долгота точки.
// В структуре ПараметрыМаршрута следующие свойства:
// "ТипМаршрута" - варианты значения - "Разомкнутый", "МеждуДвумяТочками", "ОднаТочка", "Замкнутый"
//
Функция НайтиОптимальныйМаршрутВстроенныйАлгоритм(МассивТочек, ПараметрыМаршрута) Экспорт
	
	МаксКоличествоВариантов = ПараметрыМаршрута.МаксКоличествоВариантов; // максимальное количество вариантов маршрута для эвристического анализа
	ТипМаршрута = ПолучитьКодТипаМаршрута(ПараметрыМаршрута.ТипМаршрута); // искать разомкнутый маршрут
		
	КолТочек = МассивТочек.Количество() / 2;
	
	// {{_аа20180528
	стрТочек = "";
	Сч = 0;
	Пока Сч <> МассивТочек.Количество() Цикл
		стрТочек = стрТочек + СтрЗаменить(МассивТочек[Сч + 1], ",", ".") + "," + СтрЗаменить(МассивТочек[Сч], ",", ".") + "|";
		Сч = Сч + 2;
	КонецЦикла;
	стрТочек = Лев(стрТочек, СтрДлина(стрТочек) - 1); 
	
	МРасстояния = CRM_РаботаСКартамиКлиентСервер.НайтиМатрицуРасстоянийOpenRouteService(стрТочек, ПараметрыМаршрута);
	Если МРасстояния.Количество() = 0 Тогда
		Возврат Неопределено;
	КонецЕсли;
	
	Для к = 0 По МРасстояния.Количество() - 1 Цикл	
		Для л = 0 По МРасстояния.Количество() - 1 Цикл
			Если МРасстояния[к][л] = Неопределено Тогда
				МРасстояния[к][л] = 0;	
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	МРасстояния.Вставить(0, Новый Массив (МРасстояния[0].Количество() + 1));
	сч = 1;
	Пока сч <> МРасстояния.Количество() Цикл
		МРасстояния[сч].Вставить(0, Неопределено);
		сч = сч + 1;
	КонецЦикла;	
	
	КолУвелич = ?(ТипМаршрута <= 0, 0, ТипМаршрута);
	сч1 = 0;
	Пока сч1 <> КолУвелич Цикл
		колво = МРасстояния[0].Количество();
		МРасстояния.Вставить(колво, Новый Массив (МРасстояния[0].Количество() + 1));
		сч = 1;
		Пока сч <> МРасстояния.Количество() Цикл
			МРасстояния[сч].Вставить(колво, Неопределено);
			сч = сч + 1;
		КонецЦикла;	
		сч1 = сч1 + 1;
	КонецЦикла;
	
	// // Заранее рассчитываем все расстояния между всеми точками маршрута.
	//РазмерМассиваРасстояний = КолТочек + 1 + ?(ТипМаршрута <= 0, 0, ТипМаршрута);
	// МРасстояния = Новый Массив(РазмерМассиваРасстояний, РазмерМассиваРасстояний); // массив расстояний 
	//Для Поз1 = 0 По КолТочек-1 Цикл
	//	Широта1  = МассивТочек[Поз1*2];
	//	Долгота1 = МассивТочек[Поз1*2+1];
	//	Для Поз2 = Поз1 + 1 По КолТочек-1 Цикл
	//		// Расстояния считаем симметричными, т.е. S(A,B)=S(B,A), поэтому
	//		// заполняем вернхний-правый треуголник матрицы, а нижний-левый копируем из вернхнего-правого. Но алгоритм поддерживает
		// и ассиметричные расстояния.
	//		Широта2 = МассивТочек[Поз2*2];
	//		Долгота2= МассивТочек[Поз2*2+1];
	//		Расстояние = РасстояниеМеждуТочками(Широта1,Долгота1,Широта2,Долгота2);
	//		МРасстояния[Поз1+1][Поз2
	//	+1] = Расстояние; // в массиве расстояний точки нумеруются, начиная с 1, поэтому индекс увеличен на 1
	//		МРасстояния[Поз2+1][Поз1+1] = Расстояние;
	//	КонецЦикла;
	//КонецЦикла;
	
	// {{_аа20180528
	
	Если ТипМаршрута > 0 Тогда // маршрут типа 1 (из одной точки или в одну точку) или 2 (между 2 точками)
		
		МаксРасстояние = 0;		
		Для Поз = 2 По КолТочек - 1 Цикл
			Если МРасстояния[Поз][1] > МаксРасстояние Тогда
				МаксРасстояние = МРасстояния[Поз][1];
			КонецЕсли;
		КонецЦикла;
		
		МаксВеличина = 3 * МаксРасстояние * КолТочек;
		
		Если ТипМаршрута = 1 Тогда // первая точка маршрута - это начало или конец
			// добавяем виртуальную точку		

			КолТочек = КолТочек + 1; // с учетом добавления виртуальной точки
			
			ВиртТочка = КолТочек;
			
			ОпорнаяТочка = ?(ПараметрыМаршрута.Свойство("НомерКонечнойТочки"), ПараметрыМаршрута.НомерКонечнойТочки, 1);
			// ОпорнаяТочка - это начальная или конечная точка маршрута в зависимости от параметров маршрута
			Для Поз = 1 По КолТочек Цикл
				Если Поз <> ВиртТочка Тогда
					МРасстояния[ВиртТочка][Поз] = МаксВеличина;
					МРасстояния[Поз][ВиртТочка] = МаксВеличина;
				КонецЕсли;
			КонецЦикла;
			
			Если Не ПараметрыМаршрута.Свойство("ЗакончитьВТочке") Тогда // первая точка маршрута - должна стать концом маршрута
				
				МРасстояния[ОпорнаяТочка][ВиртТочка] = МаксВеличина; 
				МРасстояния[ВиртТочка][ОпорнаяТочка] = 0;
				
			Иначе
				
				МРасстояния[ОпорнаяТочка][ВиртТочка] = 0; 
				МРасстояния[ВиртТочка][ОпорнаяТочка] = МаксВеличина;
				
			КонецЕсли;

		ИначеЕсли ТипМаршрута = 2 Тогда // первая и предпоследняя точки маршрута - начало и конец
			НачТочка  = 1;
			КонТочка  = КолТочек;
			МРасстояния[НачТочка][КонТочка] = МаксВеличина; // если тут поставить значение 0, то результат может получиться зеркальным (после удаления виртуальной вершины)
			МРасстояния[КонТочка][НачТочка] = 0;
		КонецЕсли;
		
	КонецЕсли;
	
	Если МаксКоличествоВариантов = Неопределено Тогда
		Если КолТочек <= 10 Тогда
			МаксКоличествоВариантов = 2;
		ИначеЕсли КолТочек <= 20 Тогда
			МаксКоличествоВариантов = 4;
		ИначеЕсли КолТочек <= 30 Тогда
			МаксКоличествоВариантов = 5;
		ИначеЕсли КолТочек <= 35 Тогда
			МаксКоличествоВариантов = 5;
		Иначе
			МаксКоличествоВариантов = 5;
		КонецЕсли;
	КонецЕсли;
	
	МаксКоличествоПерестановок = Неопределено; // максимальное количество перестановок (представителей первого поколения)
	// предусматриваем случай, когда заданное количество вариантов маршрута может превысить максимально возможное количество вариантов
	Если КолТочек <= 7 Тогда
		МаксКоличествоПерестановок = Факториал(КолТочек) / 2; // для симметричных расстояний число всех вариантов для N точек равно N!/2
		Если МаксКоличествоПерестановок < МаксКоличествоВариантов Тогда
			МаксКоличествоВариантов = МаксКоличествоПерестановок;
		КонецЕсли;
	КонецЕсли;
	// Все расстояния рассчитаны. Например, расстояние между точками 1 и 2: S(1,2) = МРасстояния[1][2]
	
	// { Gri++ Отладка
	СтрБуфер = "";
	Для Поз = 1 По КолТочек Цикл
		Для Поз2 = 1 По КолТочек Цикл
			СтрЧисло = ?(МРасстояния[Поз][Поз2] = Неопределено, " ", Строка(Окр(МРасстояния[Поз][Поз2], 1)));
			СтрБуфер = СтрБуфер + СтрЧисло + Символы.Таб;
		КонецЦикла;
		СтрБуфер = СтрБуфер + Символы.ПС;		
	КонецЦикла;
	// } Gri++ Отладка
	
	Если МаксКоличествоВариантов = МаксКоличествоПерестановок
		 Или КолТочек <= 5 Тогда // ищем маршрут перебором всех вариантов
		Маршрут = НайтиМаршрутПереборомВсехВариантов(КолТочек, МРасстояния, ТипМаршрута);
	Иначе // ищем маршрут эвристическим методом
		Маршрут = НайтиМаршрутЭвристически(КолТочек, МРасстояния, МаксКоличествоВариантов, ТипМаршрута);
	КонецЕсли;
	
	// В переменной Маршрут у нас лучший замкнутый маршрут 
	
	Если ТипМаршрута = -1 Тогда // маршрут нужно разомкнуть по максимальному отрезку
		// ищем максимальную длину между точками маршрута - между ними и делаем разрыв
		ПослТочка = КолТочек - 1;
		МаксДлина = МРасстояния[Маршрут[ПослТочка - 1]][Маршрут[0]]; // замыкаем маршрут   //аа_20180710
		ПозРазмыкания = 0; 
		маршрутДлина = 0; // аа_20180710
		Для Поз = 1 По ПослТочка Цикл
			Длина = МРасстояния[Маршрут[Поз - 1]][Маршрут[Поз]];
			маршрутДлина = Длина + маршрутДлина; // аа_20180710
			
			Если Длина > МаксДлина Тогда
				МаксДлина = Длина;
				ПозРазмыкания = Поз;
			КонецЕсли;
		КонецЦикла;    
				
		прДлина = Маршрут[КолТочек] - МаксДлина; // уменьшаем длину маршрута на длину отрезка размыкания
		Если прДлина < маршрутДлина Тогда // аа_20180710 
			Если ПозРазмыкания <> 0 Тогда
				РМаршрут = Новый Массив(КолТочек + 1);
				РМаршрут[КолТочек] = Маршрут[КолТочек];
				// Делаем циклический сдвиг влево, чтобы нулевым элементом массива у нас стала точка размыкания
				Для Поз = 0 По КолТочек - 1 Цикл
					РМаршрут[Поз] = Маршрут[ПозРазмыкания];
					ПозРазмыкания = (ПозРазмыкания + 1) % КолТочек;
				КонецЦикла;
				Маршрут = РМаршрут;
			КонецЕсли;
			// ((аа_20180712
			Длина = 0;
			Для Поз = 1 По ПослТочка Цикл
				Длина = Длина + МРасстояния[Маршрут[Поз - 1]][Маршрут[Поз]];
			КонецЦикла;
			Маршрут[КолТочек] = Длина;
			// ((аа_20180712
		КонецЕсли;
	ИначеЕсли ТипМаршрута = 2 Тогда // маршрут между 2 точками 
		
		// Делаем циклический сдвиг массива так, чтобы первым элементом массива у нас стала начальная точка
		ПозНачТочки = Маршрут.Найти(НачТочка);
		Если ПозНачТочки <> 0 Тогда
			РМаршрут = Новый Массив(КолТочек + 1);
			РМаршрут[КолТочек] = Маршрут[КолТочек];
			ПозИcточник = ПозНачТочки;
			Для Поз = 0 По КолТочек - 1 Цикл
				РМаршрут[Поз] = Маршрут[ПозИcточник];
				ПозИcточник = (ПозИcточник + 1) % КолТочек;
			КонецЦикла;
			Маршрут = РМаршрут;
		КонецЕсли;
		
		РассчитатьДлинуМаршрута(Маршрут, МРасстояния, КолТочек - 1, ТипМаршрута);
		
	ИначеЕсли ТипМаршрута = 1 Тогда // маршрут от одной точки или в одну точку
		
		Маршрут.Удалить(Маршрут.Найти(ВиртТочка)); // удаляем виртуальную точку
		КолТочек = КолТочек - 1;
		// Делаем циклический сдвиг массива так, чтобы первым элементом массива у нас стала начальная точка (или последним - конечная,
			// в зависимости от параметров маршрута)
		ПозТочки = Маршрут.Найти(ОпорнаяТочка);
		НужнаяПоз = ОпорнаяТочка - 1;
		Если ПозТочки <> НужнаяПоз Тогда
			РМаршрут = Новый Массив(КолТочек + 1);
			ПозИcточник = ПозТочки;
			Поз = НужнаяПоз;
			// BSLLS:UnusedLocalVariable-off
			Для Шаг = 1 По КолТочек Цикл
			// BSLLS:UnusedLocalVariable-on
				РМаршрут[Поз] = Маршрут[ПозИcточник];
				ПозИcточник = (ПозИcточник + 1) % КолТочек;
				Поз = (Поз + 1) % КолТочек;
			КонецЦикла;
			Маршрут = РМаршрут;
		КонецЕсли;
		
		РассчитатьДлинуМаршрута(Маршрут, МРасстояния, КолТочек - 1, ТипМаршрута);
		
	ИначеЕсли ТипМаршрута = 0 Тогда // замкнутый маршрут - добавлена одна точка вне маршрута - офис или дом агента
		
		ПозОпорнойТочки = Маршрут.Найти(КолТочек);
		Если ПозОпорнойТочки <> КолТочек - 1 Тогда
			РМаршрут = Новый Массив(КолТочек + 1);
			РМаршрут[КолТочек] = Маршрут[КолТочек];
			ПозСдвиг = (КолТочек + КолТочек - 1 - ПозОпорнойТочки) % КолТочек;
			Для Поз = 0 По КолТочек - 1 Цикл
				РМаршрут[ПозСдвиг] = Маршрут[Поз];
				ПозСдвиг = (ПозСдвиг + 1) % КолТочек;
			КонецЦикла;
			Маршрут = РМаршрут;
		КонецЕсли;
		
	КонецЕсли;
	
	Возврат Маршрут;
	
КонецФункции

Функция НайтиМатрицуРасстоянийOpenRouteService(стрТочек, ПараметрыМаршрута) Экспорт
	
	#Если ВебКлиент Тогда
		Возврат Новый Массив;
	#Иначе
		КлючAPI = ПолучитьКлючApiOpenrouteservice();
		стрТочек = стрТочек;
		Прокси = Новый ИнтернетПрокси;
		Соединение = Новый HTTPСоединение("api.openrouteservice.org", , , , Прокси, 30, Новый ЗащищенноеСоединениеOpenSSL());
		мРасстояний = Новый Массив;
		ТекстЗапроса = "/matrix?api_key=" + КлючAPI + "&profile=driving-car&locations=" + стрТочек 
			+ "&sources=all&destinations=all&metrics=distance&resolve_locations=&units=m&optimized=true";
		
		Запрос = Новый HTTPЗапрос(ТекстЗапроса);
		Результат = Соединение.Получить(Запрос);
		
		Если Результат.КодСостояния = 200 Тогда
			ОтветСервера = Результат.ПолучитьТелоКакСтроку();
			ЧтениеJSON = Новый ЧтениеJSON;
			Попытка
				ЧтениеJSON.УстановитьСтроку(ОтветСервера);
				СтруктРезультат = ПрочитатьJSON(ЧтениеJSON);
				ЧтениеJSON.Закрыть();
				СтруктРезультат.Свойство("distances", мРасстояний);
			Исключение         
				Возврат мРасстояний;
			КонецПопытки;
		ИначеЕсли Результат.КодСостояния = 413 Тогда
			ТекстСообщения =
				НСтр("ru='Ошибка при построении оптимального маршрута. Превышено лимит количества обрабатываемых точек в запросе. '");
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);		
		ИначеЕсли Результат.КодСостояния = 429 Тогда
			ТекстСообщения = НСтр("ru='Ошибка при построении оптимального маршрута. Превышен лимит частоты запросов. '");
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);			
		Иначе
			ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru='Ошибка при построении оптимального маршрута. Код ошибки: %1'"),
				 Результат.КодСостояния);
			ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстСообщения);	
		КонецЕсли;
		Возврат мРасстояний;
	#КонецЕсли
КонецФункции

Функция ПолучитьКлючApiOpenrouteservice() Экспорт
	Массив = Новый Массив;
	Массив.Добавить("58d904a497c67e00015b45fc2c83e9f653114be9b7d84d2ff788b976");
	Массив.Добавить("58d904a497c67e00015b45fc4371c8b91e7d4178b7407a4298c9e6b3");
	Массив.Добавить("58d904a497c67e00015b45fc6907892209b74c45983ba27df706478e");
	Массив.Добавить("58d904a497c67e00015b45fcbab2f23aaeae4dfdb85203b344655ce1");
	ГСЧ = Новый ГенераторСлучайныхЧисел();
	Индекс = ГСЧ.СлучайноеЧисло(0, 3);
	Возврат Массив[Индекс];
КонецФункции

#КонецОбласти // ПоискКратчайшегоПути

//  Функция - Использование webkit в поле html документа
// 
// Возвращаемое значение:
//  Булево - признак использования в поле html документа механизма webkit
//
Функция ИспользованиеWebKit() Экспорт
	СистемнаяИнформация = Новый СистемнаяИнформация();
	ВерсияПлатформы = СистемнаяИнформация.ВерсияПриложения;
	
	Если ОбщегоНазначенияКлиентСервер.СравнитьВерсии(ВерсияПлатформы, "8.3.14.0") >= 0 Тогда 
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Функция СтрокуВЧисло(ИсходнаяСтрока) Экспорт
	ИсхСтрока = СокрЛП(ИсходнаяСтрока);
	Длина = СтрДлина(ИсхСтрока);
	СтрЧисло = "";
	Для Поз = 1 По Длина Цикл
		Символ = Сред(ИсхСтрока, Поз, 1);
		Код = КодСимвола(Символ);
		Если Код >= 48 И Код <= 57 Тогда 
			СтрЧисло = СтрЧисло + Символ;
		ИначеЕсли Код = 46 Или Код = 44 Тогда // Символ "." или ","
			СтрЧисло = СтрЧисло + ".";
		КонецЕсли;
	КонецЦикла;
	Если СтрДлина(СтрЧисло) = 0 Тогда
		Возврат 0;
	Иначе
		Возврат Число(СтрЧисло);
	КонецЕсли;
КонецФункции

Функция Транслит(РусскоеСлово) Экспорт
	// Multilanguage - начало
	// Необходимо дополнить русский транслит.
	// Удалять русский транслит не рекомендуется!
	РусскийАлфавит = "абвгдеёжзийклмнопрстуфхцчшщыэюяabcdefghijklmnopqrstuvwxyz1234567890";
	ТранслитАлфавит =
		"a 1b 2v 3g 4d 5e 6yo7zh8z 9i 10i 11k 12l 13m 14n 15o 16p 17r 18s 19t 20u 21f 22h 23c 24ch25sh26sh27i 28e 29yu30ya31a 32b 33c 34d 35e 36f 37g 38h 39i 40j 41k 42l 43m 44n 45o 46p 47q 48r 49s 50t 51u 52v 53w 54x 55y 56z 571 582 593 604 615 626 637 648 659 660 67";
	// Multilanguage - конец
	СловоВТранслите = "";
	
	Для Х = 1 По СтрДлина(РусскоеСлово) Цикл
		РусскаяБуква = НРег(Сред(РусскоеСлово, Х, 1));
		Н = СтрНайти(РусскийАлфавит, РусскаяБуква);
		Если Н > 0 Тогда
			Т = СтрНайти(ТранслитАлфавит, Н);
			ТранслитБуква = СокрЛП(Сред(ТранслитАлфавит, Т - 2, 2));
			СловоВТранслите = СловоВТранслите + ТранслитБуква;
		КонецЕсли;
	КонецЦикла;
	
	Возврат СловоВТранслите;
КонецФункции

Функция ЧислоВСтроку(Число) Экспорт
	
	Возврат Формат(Число, "ЧРД=.; ЧГ=");
	
КонецФункции

#КонецОбласти
